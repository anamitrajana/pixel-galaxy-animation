<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Galaxy Animation</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000;
    }
    
    #animation-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    #error-message {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: Arial, sans-serif;
      text-align: center;
      width: 80%;
    }
  </style>
</head>
<body>
  <div id="animation-container"></div>
  <div id="error-message">
    <p>Unable to display the animation.</p>
    <p>Please try a different browser or check your settings.</p>
  </div>

  <!-- Import Three.js from CDN - using UMD version to avoid import/export issues -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.147.0/three.min.js"></script>
  
  <script>
    // Wait for window to fully load before initializing
    window.addEventListener('load', function() {
      setTimeout(initAnimation, 500); // Add a delay to ensure everything is loaded
    });
    
    function initAnimation() {
      try {
        // Create a unique ID for this instance
        const uniqueId = 'galaxy-animation-' + Math.random().toString(36).substr(2, 9);
        
        // Create a container with the unique ID
        const container = document.getElementById('animation-container');
        const canvas = document.createElement('canvas');
        canvas.id = uniqueId;
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        container.appendChild(canvas);
        
        // Check if WebGL is available
        if (!isWebGLAvailable()) {
          throw new Error('WebGL not supported');
        }
        
        // Configuration
        const PARTICLE_COUNT = 2000;
        const EARTH_RADIUS = 3;
        const PRIMARY_COLOR = new THREE.Color("#F15A24");
        
        // Create scene
        const scene = new THREE.Scene();
        
        // Create camera
        const width = container.clientWidth || window.innerWidth;
        const height = container.clientHeight || window.innerHeight;
        const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        camera.position.z = 10;
        
        // Create renderer with explicit canvas
        const renderer = new THREE.WebGLRenderer({
          canvas: canvas,
          antialias: false,
          alpha: true,
          powerPreference: 'default'
        });
        renderer.setSize(width, height);
        renderer.setPixelRatio(1); // Use lower pixel ratio for better performance
        
        // Add light
        const light = new THREE.AmbientLight(0xffffff);
        scene.add(light);
        
        // Create galaxy particles
        const galaxyGeometry = new THREE.BufferGeometry();
        const galaxyPositions = new Float32Array(PARTICLE_COUNT * 3);
        const galaxyColors = new Float32Array(PARTICLE_COUNT * 3);
        
        // Create earth particles
        const earthGeometry = new THREE.BufferGeometry();
        const earthPositions = new Float32Array(PARTICLE_COUNT * 3);
        const earthColors = new Float32Array(PARTICLE_COUNT * 3);
        
        // Fill positions and colors
        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const i3 = i * 3;
          
          // Galaxy positions
          const radius = 10 + Math.random() * 10;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          
          galaxyPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
          galaxyPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
          galaxyPositions[i3 + 2] = radius * Math.cos(phi);
          
          // Earth positions
          const earthPhi = Math.acos(2 * Math.random() - 1);
          const earthTheta = Math.random() * Math.PI * 2;
          
          earthPositions[i3] = EARTH_RADIUS * Math.sin(earthPhi) * Math.cos(earthTheta);
          earthPositions[i3 + 1] = EARTH_RADIUS * Math.sin(earthPhi) * Math.sin(earthTheta);
          earthPositions[i3 + 2] = EARTH_RADIUS * Math.cos(earthPhi);
          
          // Colors
          const intensity = 0.5 + Math.random() * 0.5;
          galaxyColors[i3] = PRIMARY_COLOR.r * intensity;
          galaxyColors[i3 + 1] = PRIMARY_COLOR.g * intensity;
          galaxyColors[i3 + 2] = PRIMARY_COLOR.b * intensity;
          
          earthColors[i3] = PRIMARY_COLOR.r * intensity;
          earthColors[i3 + 1] = PRIMARY_COLOR.g * intensity;
          earthColors[i3 + 2] = PRIMARY_COLOR.b * intensity;
        }
        
        // Set attributes
        galaxyGeometry.setAttribute('position', new THREE.BufferAttribute(galaxyPositions, 3));
        galaxyGeometry.setAttribute('color', new THREE.BufferAttribute(galaxyColors, 3));
        
        earthGeometry.setAttribute('position', new THREE.BufferAttribute(earthPositions, 3));
        earthGeometry.setAttribute('color', new THREE.BufferAttribute(earthColors, 3));
        
        // Create material
        const material = new THREE.PointsMaterial({
          size: 0.08,
          vertexColors: true,
          transparent: true,
          opacity: 0.8
        });
        
        // Create points
        const particles = new THREE.Points(galaxyGeometry.clone(), material.clone());
        scene.add(particles);
        
        // Animation variables
        let phase = 0; // 0: galaxy, 1: transition to earth, 2: earth, 3: transition to galaxy
        let progress = 0;
        let elapsedTime = 0;
        let mouseX = 0;
        let mouseY = 0;
        
        // Mouse tracking
        document.addEventListener('mousemove', function(event) {
          mouseX = (event.clientX / width) * 2 - 1;
          mouseY = -(event.clientY / height) * 2 + 1;
        });
        
        // Handle resize
        window.addEventListener('resize', function() {
          const newWidth = container.clientWidth || window.innerWidth;
          const newHeight = container.clientHeight || window.innerHeight;
          
          camera.aspect = newWidth / newHeight;
          camera.updateProjectionMatrix();
          
          renderer.setSize(newWidth, newHeight);
        });
        
        // Animation loop
        const clock = new THREE.Clock();
        
        function animate() {
          const delta = clock.getDelta();
          elapsedTime += delta;
          
          // Update animation phase
          if (phase === 0 && elapsedTime > 2) {
            phase = 1; // Start transition to earth
          } else if (phase === 1) {
            progress += delta * 0.2; // 5 seconds transition
            if (progress >= 1) {
              progress = 1;
              phase = 2;
            }
          } else if (phase === 2 && elapsedTime > 10) {
            phase = 3; // Start transition to galaxy
          } else if (phase === 3) {
            progress -= delta * 0.25; // 4 seconds transition
            if (progress <= 0) {
              progress = 0;
              phase = 0;
              elapsedTime = 0;
            }
          }
          
          // Update positions
          const positions = particles.geometry.attributes.position.array;
          
          for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            
            // Interpolate between galaxy and earth
            positions[i3] = galaxyPositions[i3] * (1 - progress) + earthPositions[i3] * progress;
            positions[i3 + 1] = galaxyPositions[i3 + 1] * (1 - progress) + earthPositions[i3 + 1] * progress;
            positions[i3 + 2] = galaxyPositions[i3 + 2] * (1 - progress) + earthPositions[i3 + 2] * progress;
            
            // Apply hover effect
            if (Math.abs(mouseX) > 0.1 || Math.abs(mouseY) > 0.1) {
              const x = positions[i3];
              const y = positions[i3 + 1];
              const z = positions[i3 + 2];
              
              // Create a 3D point for the particle
              const particlePos = new THREE.Vector3(x, y, z);
              
              // Create a 3D point for the mouse (project into scene)
              const mousePos = new THREE.Vector3(mouseX * 5, mouseY * 5, 0);
              
              // Calculate distance
              const distance = particlePos.distanceTo(mousePos);
              
              // Apply repulsion if close
              if (distance < 2) {
                const force = (2 - distance) * 0.05;
                const direction = new THREE.Vector3().subVectors(particlePos, mousePos).normalize();
                
                positions[i3] += direction.x * force;
                positions[i3 + 1] += direction.y * force;
                positions[i3 + 2] += direction.z * force;
              }
            }
          }
          
          particles.geometry.attributes.position.needsUpdate = true;
          
          // Rotate
          particles.rotation.y += 0.001;
          
          // Render
          renderer.render(scene, camera);
          
          // Continue animation
          requestAnimationFrame(animate);
        }
        
        // Start animation
        animate();
        
        // Notify parent when ready
        if (window.parent) {
          window.parent.postMessage({ type: 'ready' }, '*');
        }
        
      } catch (error) {
        console.error("Animation error:", error);
        document.getElementById('error-message').style.display = 'block';
        document.getElementById('animation-container').style.display = 'none';
      }
    }
    
    // Check if WebGL is available
    function isWebGLAvailable() {
      try {
        const canvas = document.createElement('canvas');
        return !!(
          window.WebGLRenderingContext && 
          (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))
        );
      } catch (e) {
        return false;
      }
    }
  </script>
</body>
</html>

