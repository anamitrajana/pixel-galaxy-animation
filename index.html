"use client"

import { useRef, useMemo, useEffect, useState } from "react"
import { Canvas, useFrame, useThree } from "@react-three/fiber"
import { PerspectiveCamera } from "@react-three/drei"
import * as THREE from "three"

const PARTICLE_COUNT = 5000
const EARTH_RADIUS = 2
const PRIMARY_COLOR = new THREE.Color("#F15A24") // Orange theme color
const HOVER_RADIUS = 2 // Radius of influence for hover effect
const HOVER_STRENGTH = 0.8 // Strength of the hover dispersion effect
const ANIMATION_DURATION = 18 // Total duration of one complete animation cycle in seconds
const INITIAL_TRANSITION_DURATION = 100 // Duration of the initial transition in seconds
const HOLD_DURATION = 3 // Duration to hold the Earth shape
const RETURN_TRANSITION_DURATION = 4 // Duration of the transition back to galaxy

// Easing functions
function easeInOutCubic(x: number): number {
  return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2
}

function easeOutQuint(x: number): number {
  return 1 - Math.pow(1 - x, 5)
}

function Particles() {
  const { viewport, mouse, camera, clock } = useThree()
  const pointsRef = useRef<THREE.Points>(null)
  const mouseRef = useRef(new THREE.Vector2())
  const [animationStartTime, setAnimationStartTime] = useState(0)
  const animationStarted = useRef(false)

  // Update mouse position
  useEffect(() => {
    const handleMouseMove = (event: MouseEvent) => {
      // Convert mouse position to normalized device coordinates (-1 to +1)
      mouseRef.current.x = (event.clientX / window.innerWidth) * 2 - 1
      mouseRef.current.y = -(event.clientY / window.innerHeight) * 2 + 1
    }

    window.addEventListener("mousemove", handleMouseMove)
    return () => window.removeEventListener("mousemove", handleMouseMove)
  }, [])

  // Create particles with initial random positions (galaxy)
  const [galaxyPositions, colors] = useMemo(() => {
    const positions = new Float32Array(PARTICLE_COUNT * 3)
    const colors = new Float32Array(PARTICLE_COUNT * 3)

    for (let i = 0; i < PARTICLE_COUNT; i++) {
      // Random positions in a spherical distribution for galaxy
      const radius = 10 + Math.random() * 10
      const theta = Math.random() * Math.PI * 2
      const phi = Math.acos(2 * Math.random() - 1)

      positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta)
      positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta)
      positions[i * 3 + 2] = radius * Math.cos(phi)

      // Colors with orange theme
      const intensity = 0.5 + Math.random() * 0.5
      colors[i * 3] = PRIMARY_COLOR.r * intensity // Red
      colors[i * 3 + 1] = PRIMARY_COLOR.g * intensity // Green
      colors[i * 3 + 2] = PRIMARY_COLOR.b * intensity // Blue
    }

    return [positions, colors]
  }, [])

  // Create target positions for the Earth sphere
  const earthPositions = useMemo(() => {
    const positions = new Float32Array(PARTICLE_COUNT * 3)

    for (let i = 0; i < PARTICLE_COUNT; i++) {
      // Create points distributed on a sphere (Earth)
      const phi = Math.acos(2 * Math.random() - 1)
      const theta = Math.random() * Math.PI * 2

      positions[i * 3] = EARTH_RADIUS * Math.sin(phi) * Math.cos(theta)
      positions[i * 3 + 1] = EARTH_RADIUS * Math.sin(phi) * Math.sin(theta)
      positions[i * 3 + 2] = EARTH_RADIUS * Math.cos(phi)
    }

    return positions
  }, [])

  // Animation frame
  useFrame(() => {
    if (!pointsRef.current) return

    const points = pointsRef.current
    const positionAttribute = points.geometry.getAttribute("position") as THREE.BufferAttribute
    const currentTime = clock.getElapsedTime()

    // Initialize animation start time
    if (!animationStarted.current) {
      setAnimationStartTime(currentTime)
      animationStarted.current = true
    }

    // Calculate time since animation started
    const elapsedTime = currentTime - animationStartTime

    // Calculate animation cycle time
    const cycleTime = elapsedTime % ANIMATION_DURATION

    // Calculate progress based on which phase of the animation we're in
    let progress = 0

    if (cycleTime < INITIAL_TRANSITION_DURATION) {
      // Initial slow transition to Earth (5 seconds with easing)
      const phaseProgress = cycleTime / INITIAL_TRANSITION_DURATION
      progress = easeOutQuint(phaseProgress)
    } else if (cycleTime < INITIAL_TRANSITION_DURATION + HOLD_DURATION) {
      // Hold Earth shape (3 seconds)
      progress = 1
    } else if (cycleTime < INITIAL_TRANSITION_DURATION + HOLD_DURATION + RETURN_TRANSITION_DURATION) {
      // Transition back to galaxy (4 seconds with easing)
      const phaseProgress = (cycleTime - INITIAL_TRANSITION_DURATION - HOLD_DURATION) / RETURN_TRANSITION_DURATION
      progress = 1 - easeInOutCubic(phaseProgress)
    } else {
      // Hold galaxy shape for the remainder of the cycle
      progress = 0
    }

    // Create a raycaster for mouse interaction
    const raycaster = new THREE.Raycaster()
    raycaster.setFromCamera(mouseRef.current, camera)

    // Calculate a point in 3D space where the mouse is pointing
    const mousePoint = new THREE.Vector3()
    raycaster.ray.at(10, mousePoint) // 10 units into the scene

    // Update each particle position
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      const i3 = i * 3

      // Calculate the interpolated position based on animation progress
      const galaxyX = galaxyPositions[i3]
      const galaxyY = galaxyPositions[i3 + 1]
      const galaxyZ = galaxyPositions[i3 + 2]

      const earthX = earthPositions[i3]
      const earthY = earthPositions[i3 + 1]
      const earthZ = earthPositions[i3 + 2]

      // Directly interpolate between galaxy and earth positions based on animation progress
      let x = galaxyX * (1 - progress) + earthX * progress
      let y = galaxyY * (1 - progress) + earthY * progress
      let z = galaxyZ * (1 - progress) + earthZ * progress

      // Create a particle position vector for hover effect
      const particlePos = new THREE.Vector3(x, y, z)

      // Calculate distance to mouse ray
      const distanceToMouse = particlePos.distanceTo(mousePoint)

      // Apply hover dispersion effect if close to mouse
      if (distanceToMouse < HOVER_RADIUS) {
        // Calculate repel force based on distance (stronger when closer)
        const repelStrength = (1 - distanceToMouse / HOVER_RADIUS) * HOVER_STRENGTH

        // Direction from mouse to particle
        const repelDir = particlePos.clone().sub(mousePoint).normalize()

        // Apply repel force
        x += repelDir.x * repelStrength
        y += repelDir.y * repelStrength
        z += repelDir.z * repelStrength
      }

      // Update the position
      positionAttribute.setXYZ(i, x, y, z)
    }

    positionAttribute.needsUpdate = true

    // Rotate the entire points system (slower during Earth formation)
    const rotationSpeed = 0.001 * (1 - progress * 0.7)
    points.rotation.y += rotationSpeed
  })

  return (
    <points ref={pointsRef}>
      <bufferGeometry>
        <bufferAttribute attach="attributes-position" count={PARTICLE_COUNT} array={galaxyPositions} itemSize={3} />
        <bufferAttribute attach="attributes-color" count={PARTICLE_COUNT} array={colors} itemSize={3} />
      </bufferGeometry>
      <pointsMaterial size={0.08} sizeAttenuation={true} vertexColors transparent opacity={0.8} />
    </points>
  )
}

function Scene() {
  return (
    <>
      <PerspectiveCamera makeDefault position={[0, 0, 10]} />
      <ambientLight intensity={0.5} />
      <directionalLight position={[5, 3, 5]} intensity={1} />
      <Particles />
    </>
  )
}

export default function GalaxyScene() {
  return (
    <div className="absolute inset-0 bg-black">
      <Canvas>
        <Scene />
      </Canvas>
    </div>
  )
}

